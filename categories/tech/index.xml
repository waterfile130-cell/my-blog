<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech on LoveIt</title><link>https://1water1.top/categories/tech/</link><description>Recent content in Tech on LoveIt</description><generator>Hugo</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 29 Dec 2025 14:20:14 +0800</lastBuildDate><atom:link href="https://1water1.top/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>keepalived</title><link>https://1water1.top/whats-keepalived/</link><pubDate>Tue, 23 Dec 2025 10:14:01 +0800</pubDate><guid>https://1water1.top/whats-keepalived/</guid><description>&lt;h3 id="1-什么是高可用-high-availability-ha"&gt;1. 什么是高可用 (High Availability, HA)？&lt;/h3&gt;
&lt;p&gt;在 IT 领域，&amp;lsquo;高可用&amp;rsquo;指的是系统在面对硬件故障、软件错误或网络问题时，仍能长时间持续提供服务的能力。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'目标'：消除单点故障（SPOF）。如果一台服务器挂了，另一台能立马顶上。
'衡量标准'：通常用“几个9”来衡量，比如 99.99%（意味着一年停机时间不超过 52 分钟）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lsquo;Keepalived&amp;rsquo; 就是Linux下一个轻量级的高可用解决方案，它最初是为 LVS（Linux Virtual Server）设计的，用来管理并监控负载均衡集群中的服务节点状态。&lt;/p&gt;
&lt;h3 id="2-核心基石vrrp-协议"&gt;2. 核心基石：VRRP 协议&lt;/h3&gt;
&lt;p&gt;要懂 Keepalived，必须先懂 &amp;lsquo;VRRP&amp;rsquo; (Virtual Router Redundancy Protocol，虚拟路由器冗余协议)。Keepalived 就是用 C 语言实现了 VRRP 协议。&lt;/p&gt;
&lt;h4 id="vrrp-的工作原理"&gt;VRRP 的工作原理：&lt;/h4&gt;
&lt;p&gt;想象一下，你有一群路由器，我们想让它们在外面看起来像&amp;rsquo;一台&amp;rsquo;超级路由器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lsquo;虚拟 IP (VIP)&amp;rsquo;：这是对外提供服务的 IP 地址。客户端只连接这个 IP，不知道后面具体是哪台机器。&lt;/li&gt;
&lt;li&gt;&amp;lsquo;角色&amp;rsquo;：
&amp;rsquo; &amp;lsquo;Master (主节点)&amp;rsquo;：真正持有 VIP，负责处理流量，并周期性地向 Backup 发送“我还活着”的广播包（心跳）。
&amp;rsquo; &amp;lsquo;Backup (备节点)&amp;rsquo;：监听 Master 的广播。&lt;/li&gt;
&lt;li&gt;&amp;lsquo;选举与故障切换 (Failover)&amp;rsquo;：
&amp;rsquo; Backup 如果在一定时间内（通常是3秒）收不到 Master 的心跳包，就认为 Master 挂了。
&amp;rsquo; Backup 根据优先级（Priority）选举出新的 Master，接管 VIP。
&amp;rsquo; 一旦旧 Master 恢复，根据配置（抢占模式），它可能会重新夺回 VIP。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3-keepalived-基础知识"&gt;3. Keepalived 基础知识&lt;/h3&gt;
&lt;p&gt;Keepalived 主要有两个核心功能：&lt;/p&gt;</description></item><item><title>Building a Keepalived + Nginx Dual-Master HA Cluster from Scratch (Ubuntu 24.04)</title><link>https://1water1.top/building-keepalived-nginx-dual-master-ha-cluster/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate><guid>https://1water1.top/building-keepalived-nginx-dual-master-ha-cluster/</guid><description>&lt;h1 id="building-a-keepalived--nginx-dual-master-ha-cluster-from-scratch-ubuntu-2404"&gt;Building a Keepalived + Nginx Dual-Master HA Cluster from Scratch (Ubuntu 24.04)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Preface&lt;/strong&gt;:
I recently grabbed a domain for just a dollar and decided to tinker with server high availability architectures.
In a production environment, a single point of failure (SPOF) is a DevOps nightmare. Today, I&amp;rsquo;m documenting how I used Keepalived to implement a &lt;strong&gt;Dual-Master (Active-Active)&lt;/strong&gt; architecture.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Goal&lt;/strong&gt;: Two servers acting as backups for each other. Normally, each handles one VIP (Virtual IP). If one server fails, the other instantly takes over all traffic!&lt;/p&gt;</description></item></channel></rss>